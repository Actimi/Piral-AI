// ../codegen-lib/lib/esm/index.mjs
import { dirname } from "path";
import { readFile } from "fs/promises";
import { createRequire } from "module";
function reloadGenerator(requireModule, name) {
  const path = requireModule.resolve(name);
  delete requireModule.cache[path];
  return requireModule(name);
}
function noop() {
}
async function dynamicCodegenImport(file) {
  const dir = dirname(file);
  const text = await readFile(file, "utf8");
  const code = replaceRelativeImports(text, dir);
  const content = Buffer.from(code).toString("base64");
  const url = `data:text/javascript;base64,${content}`;
  return await import(url);
}
function replaceRelativeImports(content, absoluteBase) {
  const regex = /import\s+([^'"]+)\s+from\s+(['"])\.\/([^'"]+)\2/g;
  return content.replace(regex, (_, imports, quote, relativePath) => {
    const absolutePath = `${absoluteBase}/${relativePath}`;
    return `import ${imports} from ${quote}file://${absolutePath}${quote}`;
  });
}
function createCodegenHost(fileOrDirName) {
  const requireModule = createRequire(fileOrDirName);
  const host = {
    load(name, type) {
      switch (type) {
        case "cjs":
          return Promise.resolve(reloadGenerator(requireModule, name));
        case "esm":
          return dynamicCodegenImport(name).then((result) => result.default || result);
        case "auto":
        default:
          if (name.endsWith(".mjs.codegen") || name.endsWith(".esm.codegen") || name.endsWith(".module.codegen") || name.endsWith(".m.codegen")) {
            return host.load(name, "esm");
          }
          return host.load(name, "cjs");
      }
    },
    async generate(details) {
      const { name, type = "auto", options = {}, addDependency = noop } = details;
      if (typeof name !== "string") {
        throw new Error(`You need to pass in a string for "name". Received: "${name}".`);
      }
      const generator = await host.load(name, type);
      if (typeof generator !== "function") {
        throw new Error(`The codegen module "${name}" does not export a function and is invalid.`);
      }
      const result = await generator.call({
        name,
        options,
        addDependency
      });
      if (typeof result === "string") {
        const type2 = typeof generator.type === "string" ? generator.type : "js";
        return {
          type: type2,
          value: result
        };
      }
      if (result && typeof result === "object" && typeof result.value === "string" && typeof result.type === "string") {
        return result;
      }
      throw new Error(
        `The codegen module "${name}" did not generate a valid result (string or object). It returned: "${result}".`
      );
    }
  };
  return host;
}

// src/index.ts
var defaultOptions = { outDir: "dist", rootDir: process.cwd() };
function codegen(options = defaultOptions) {
  const { rootDir = defaultOptions.rootDir, outDir = defaultOptions.outDir } = options;
  const codegen2 = createCodegenHost(rootDir);
  return {
    name: "codegen",
    resolveId(source) {
      if (source.endsWith(".codegen")) {
        return source;
      }
      return null;
    },
    async load(name) {
      if (name.endsWith(".codegen")) {
        const result = await codegen2.generate({
          name,
          options: {
            outDir,
            rootDir
          },
          addDependency: (file) => {
            this.addWatchFile(file);
          }
        });
        return result.value;
      }
      return null;
    }
  };
}
export {
  codegen as default
};
//# sourceMappingURL=index.mjs.map
