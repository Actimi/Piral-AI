var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/index.ts
var index_exports = {};
__export(index_exports, {
  default: () => codegen
});
module.exports = __toCommonJS(index_exports);

// ../codegen-lib/lib/esm/index.mjs
var import_path = require("path");
var import_promises = require("fs/promises");
var import_module = require("module");
function reloadGenerator(requireModule, name) {
  const path = requireModule.resolve(name);
  delete requireModule.cache[path];
  return requireModule(name);
}
function noop() {
}
async function dynamicCodegenImport(file) {
  const dir = (0, import_path.dirname)(file);
  const text = await (0, import_promises.readFile)(file, "utf8");
  const code = replaceRelativeImports(text, dir);
  const content = Buffer.from(code).toString("base64");
  const url = `data:text/javascript;base64,${content}`;
  return await import(url);
}
function replaceRelativeImports(content, absoluteBase) {
  const regex = /import\s+([^'"]+)\s+from\s+(['"])\.\/([^'"]+)\2/g;
  return content.replace(regex, (_, imports, quote, relativePath) => {
    const absolutePath = `${absoluteBase}/${relativePath}`;
    return `import ${imports} from ${quote}file://${absolutePath}${quote}`;
  });
}
function createCodegenHost(fileOrDirName) {
  const requireModule = (0, import_module.createRequire)(fileOrDirName);
  const host = {
    load(name, type) {
      switch (type) {
        case "cjs":
          return Promise.resolve(reloadGenerator(requireModule, name));
        case "esm":
          return dynamicCodegenImport(name).then((result) => result.default || result);
        case "auto":
        default:
          if (name.endsWith(".mjs.codegen") || name.endsWith(".esm.codegen") || name.endsWith(".module.codegen") || name.endsWith(".m.codegen")) {
            return host.load(name, "esm");
          }
          return host.load(name, "cjs");
      }
    },
    async generate(details) {
      const { name, type = "auto", options = {}, addDependency = noop } = details;
      if (typeof name !== "string") {
        throw new Error(`You need to pass in a string for "name". Received: "${name}".`);
      }
      const generator = await host.load(name, type);
      if (typeof generator !== "function") {
        throw new Error(`The codegen module "${name}" does not export a function and is invalid.`);
      }
      const result = await generator.call({
        name,
        options,
        addDependency
      });
      if (typeof result === "string") {
        const type2 = typeof generator.type === "string" ? generator.type : "js";
        return {
          type: type2,
          value: result
        };
      }
      if (result && typeof result === "object" && typeof result.value === "string" && typeof result.type === "string") {
        return result;
      }
      throw new Error(
        `The codegen module "${name}" did not generate a valid result (string or object). It returned: "${result}".`
      );
    }
  };
  return host;
}

// src/index.ts
var defaultOptions = { outDir: "dist", rootDir: process.cwd() };
function codegen(options = defaultOptions) {
  const { rootDir = defaultOptions.rootDir, outDir = defaultOptions.outDir } = options;
  const codegen2 = createCodegenHost(rootDir);
  return {
    name: "codegen",
    resolveId(source) {
      if (source.endsWith(".codegen")) {
        return source;
      }
      return null;
    },
    async load(name) {
      if (name.endsWith(".codegen")) {
        const result = await codegen2.generate({
          name,
          options: {
            outDir,
            rootDir
          },
          addDependency: (file) => {
            this.addWatchFile(file);
          }
        });
        return result.value;
      }
      return null;
    }
  };
}
//# sourceMappingURL=index.cjs.map
